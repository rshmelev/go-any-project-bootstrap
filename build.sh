#!/bin/bash
# this script was created by rshmelev@gmail.com
#
# you should have gox and gom installed before running this:
# #not important for go1.5 - go get github.com/mitchellh/gox
# go get github.com/mattn/gom
# ... i'm not sure about gom now... govendor is what should be in place
# go get github.com/kardianos/govendor
# go get github.com/alecthomas/gometalinter && gometalinter --install --update

# edit this
# sample: DEFAULT_OSARCH="windows/386 windows/amd64 linux/amd64 darwin/amd64"
# sample: FILENAME_SUFFIX="-{{.OS}}-{{.Arch}}"
# sample: APPNAME="default"
AUTHOR_LONG="_________AUTHORLONG__________"
AUTHOR_SHORT="_________AUTHORSHORT__________"
SITEURL="_________SITE__________"
DEFAULT_OSARCH="linux/amd64"

APPNAME="default"
BUILD_IN_PARALLEL=true
TRIM_GO_PREFIX=true
AUTHOR_PREFIX="${AUTHOR_SHORT}-"
FILENAME_SUFFIX="-{{.OS}}"

work() {

    [ -z "${AUTHOR_SHORT}" ] && AUTHOR_PREFIX=
    [ "$APPNAME" == "default" ] && APPNAME="$(basename $(pwd))"

    BINDIR="./bin"
    BUILDOSARCH=${1-${DEFAULT_OSARCH}}

    [ "$TRIM_GO_PREFIX" == "true" ] && FILENAME=${FILENAME#go-*} && APPNAME=${APPNAME#go-*}

    APPNAME="${AUTHOR_PREFIX}${APPNAME}"
    FILENAME="${APPNAME}${FILENAME_SUFFIX}"

    [ ! -z "${BUILD_OPTION}" ] && FILENAME="debug-${FILENAME}"

    mkdir -p "$BINDIR"

    # calculating
    v=`go version`
    goversion=${v#*go version }
    buildtime=`date -u "+%Y-%m-%d %H:%M:%S"`

    if [ -d .git ] ; then
        rev=`git rev-parse HEAD 2>/dev/null`
        if [ ! "$rev" == "HEAD" ]; then
            rev=`git rev-parse HEAD`
            branch=`git rev-parse --abbrev-ref HEAD`
            gittag=`git describe --tags --exact-match 2>/dev/null`
            modifiedfiles="$(git --no-pager diff --name-only --ignore-all-space)"
            modifiedfiles="$(echo "${modifiedfiles}" | grep -v main-autogenerated.go )"
            modifiedfiles="$(echo "${modifiedfiles}" | grep -v Gomfile )"
            modsrc="$(process_modified_files "${modifiedfiles}")"
        fi
    fi

    create_main_go

    # gotype is not working well for some reason :(
    echoo "running metalinter"
    gometalinter ./code/... | grep -v gotype

    echoo "running go fmt ./code/..."
    go fmt ./code/...

    echoo "updating Gomfile"
    [ -f Gomfile ] && rm Gomfile
    gom gen gomfile
    gomfile="$(cat Gomfile | grep -v `get_current_package`)"
    echo "$gomfile" > Gomfile

    echoo "calculating dependencies"
    calc_dependencies

    echoo "building"
    start=`date +%s`
      build_all
    end=`date +%s`
    echo "...finished in $((end-start)) seconds"
}

#-------------------------------------------------------

echoo() {
    echo -e "\n... $@"
}
calc_dependencies() {
    d="$(go list -f '{{join .Deps "\n"}}' |  xargs go list -f '{{if not .Standard}}{{.ImportPath}}{{end}}')"
    d="$(echo "$d" | grep -v `get_current_package`/code )"
    d="$(echo "${d}" | tr '\n\r' ';')"

    thisdir=`pwd`
    var=${d}
    res=""
    while [ "$var" ] ;do
        iter=${var%%\;*}
        libpath="${GOPATH}/src/$iter"
        if [ -d "$libpath/.git" ] ||  [ -d "$libpath/../.git" ] ||  [ -d "$libpath/../../.git" ]  ; then
            cd "$libpath"
            librev=`git rev-parse HEAD`
            libbranch=`git rev-parse --abbrev-ref HEAD`
            libmod=`git --no-pager show -s --format=%cI ${librev}`

            dirty="clean"
            [ "$(evil_git_dirty)" == "*" ] && dirty="dirty"
            [ ! "$(evil_git_num_untracked_files)" == "0" ] && dirty="dirty"

            if [ ! "$dirty" == "clean" ] ; then
                echo "WARNING: library '$iter' is dirty"
                git status -s
            fi

            res="${res};${iter}=${dirty}/${libbranch}/${librev}/${libmod}"
        else
            [[ ${iter} == *"/vendor"* ]] || echo "WARNING: library '${iter}' is probably not under version control"
            res="${res};${iter}=unknown"
        fi
        [ "$var" = "$iter" ] && var='' || var="${var#*;}"
    done

    cd ${thisdir}
    projdeps="${res}"
}

# Returns "*" if the current git branch is dirty.
function evil_git_dirty {
  [[ $(git diff --shortstat 2> /dev/null | tail -n1) != "" ]] && echo "*"
}
# Returns the number of untracked files
function evil_git_num_untracked_files {
  expr `git status --porcelain 2>/dev/null| grep "^??" | wc -l`
}

process_modified_files() {
    modifiedfiles="$1"
    modsrc="$(echo "${modifiedfiles}" | tr '\n\r' ';')"
    var=${modsrc}
    res=""
    while [ "$var" ] ;do
        iter=${var%%\;*}
        if [ ! -z "$iter" ] ; then
            mod=`portable_get_modification_time "${iter}"`
            res="${res};${iter}=${mod}"
        fi
        [ "$var" = "$iter" ] && var='' || var="${var#*;}"
    done

    echo "$res"
}

# accepts file name as param
portable_get_modification_time() {
    file=$1
    if [ -f "${file}" ]; then
        unamestr=`uname`
        if [ "$unamestr" == "Linux" ]; then
            res=`stat -c '%Y' "${file}"`
            x=`date -u -d @${res}`
        else
            res=`stat -f "%m" "${file}"`
            x=`date -u -r ${res}`
        fi
        echo "$res/$x"
    else
        echo "deleted"
    fi
}

build_all() {
    PACK="github.com/rshmelev/go-project-bootstrap-kit"
    LDFLAGS="-X '${PACK}.Deps=$projdeps' -X '${PACK}.CodeRev=$rev' -X '${PACK}.GoVersion=$goversion' -X '${PACK}.BuildTime=$buildtime'"
    LDFLAGS="${LDFLAGS} -X '${PACK}.BuildOption=${BUILD_OPTION}'"
    LDFLAGS="${LDFLAGS} -X '${PACK}.Tag=${gittag}' -X '${PACK}.Branch=${branch}' -X '${PACK}.ModifiedSources=$modsrc'"

    gover=`go version`
    if [[ "$gover" =~ *go1.3* ]] || [[ "$gover" =~ *go1.4* ]] || [[ "$gover" =~ *go1.2* ]] || [[ "$gover" =~ *go1.1* ]] ; then
        LDFLAGS=${LDFLAGS//=/ }
    fi

    if type "gox" >/dev/null 2>&1 ; then
        gox -ldflags="$LDFLAGS" -osarch="$BUILDOSARCH" -output="$BINDIR/$FILENAME"
    else
        gox_sh "$LDFLAGS"
    fi

    ls -la ${BINDIR} | grep "${APPNAME}"
}

gox_sh() {
    ldflags="$1"
    var=${BUILDOSARCH}
    while [ "$var" ] ;do
        iter=${var%% *}
        if [ "$BUILD_IN_PARALLEL" = "true" ]; then
            go_build ${iter} "${ldflags}" &
        else
            go_build ${iter} "${ldflags}"
        fi

        [ "$var" = "$iter" ] && var='' || var="${var#* }"
    done

    # wait for all started
    var=${BUILDOSARCH}
    while [ "$var" ] ;do
        iter=${var%% *}
        wait
        [ "$var" = "$iter" ] && var='' || var="${var#* }"
    done

}

go_build() {
    BUILDOS=${1%/*}
    BUILDARCH=${1#*/}
    LDFLAGS=$2

    EXE="${FILENAME//\{\{.OS\}\}/$BUILDOS}"
    EXE="${EXE//\{\{.Arch\}\}/$BUILDARCH}"

    [ "$BUILDOS" == "windows" ] && EXE=${EXE}.exe

    echo "building for $BUILDOS $BUILDARCH: ${EXE}"

    env GOOS=${BUILDOS} GOARCH=${BUILDARCH} \
        go build -i -ldflags "$LDFLAGS" -o "${BINDIR}/${EXE}"

    echo "finished building ${EXE}"
}

get_current_package() {
    packagepath=`pwd`
    echo ${packagepath#*src/}
}
create_main_go() {
package=`get_current_package`
cat <<EOT > main-autogenerated.go
package main

// autogenerated by build.sh

import (
    "${package}/code"
    kit "github.com/rshmelev/go-any-project-bootstrap/launcher"
)

var v = code.BuildVars

func main() {
    v["Author"] = "${AUTHOR_LONG}"
	v["AuthorShort"] = "${AUTHOR_SHORT}"
	v["AppName"] = "${APPNAME}"
	v["Site"] = "${SITEURL}"

    kit.Bootstrap(code.Main, v)
}
EOT
}

be_able_to_cancel() {
    function handle_sigint() {
        for proc in `jobs -p` ; do
            kill ${proc}
        done
    }
    trap handle_sigint SIGINT
}
#----------------------------------------------------


if [ ! "${BUILD_OPTION}" == "just-gather-project-details" ] ; then
    be_able_to_cancel
    work "$@"
fi

